using System;
using System.Globalization;
using System.Linq;
using System.Text;
using Cvte.Compiler;
using static System.Environment;

namespace Cvte.Escort
{
#pragma warning disable CS3016 // Arrays as attribute arguments is not CLS-compliant
    /// <summary>
    /// 这是一个在编译期间使用的类，目的是转换单参数泛型（T）到多参数泛型（T1, T2...Tn）。
    /// </summary>
    [CompileTimeCode("ActionCommand1.cs", "AsyncCommand1.cs", "CommandParameter1.cs",
        "ExclusiveCommand1.cs", "IParameterProvider1.cs", "ParameterExtractor1.cs",
        RepeatCount = 3, KeepSourceFiles = true)]
#pragma warning restore CS3016 // Arrays as attribute arguments is not CLS-compliant
    internal class GenericGenerator : IPlainCodeTransformer
    {
        private const string ToolName = "Cvte.Escort.MVVM";
        private const string ToolVersion = "1.0";

        private static readonly string GeneratedHeader =
            $@"//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:{Environment.Version.ToString(4)}
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

#define GENERATED_CODE

";

        private static readonly string Generatedattribute =
            $"[System.CodeDom.Compiler.GeneratedCode(\"{ToolName}\", \"{ToolVersion}\")]";

        /// <summary>
        /// 将原始的单泛型参数的类型源码转换成多泛型参数的源码。
        /// </summary>
        /// <param name="originalText">原始的单泛型参数的类型源码。</param>
        /// <param name="context">转换所需要的上下文信息。</param>
        /// <returns>转换后的新文本。</returns>
        public string Transform(string originalText, TransformingContext context)
        {
            // 重复序号为 0, 1, 2…… 但是我们的起始转换泛型个数是 2（1 是手写的，无需转换），所以要增加 2。
            var genericCount = context.RepeatIndex + 2;

            var content = new StringBuilder(originalText)
                // 替换泛型。
                .Replace("<out T>", FromTemplate("<{0}>", "out T{n}", ", ", genericCount))
                .Replace("Task<T>", FromTemplate("Task<({0})>", "T{n}", ", ", genericCount))
                .Replace("Func<T, Task>", FromTemplate("Func<{0}, Task>", "T{n}", ", ", genericCount))
                .Replace(" T, Task>", FromTemplate(" {0}, Task>", "T{n}", ", ", genericCount))
                .Replace("(T, bool", FromTemplate("({0}, bool", "T{n}", ", ", genericCount))
                .Replace("var (t, ", FromTemplate("var ({0}, ", "t{n}", ", ", genericCount))
                .Replace(", t)", FromTemplate(", {0})", "t{n}", ", ", genericCount))
                .Replace("return (t, ", FromTemplate("return ({0}, ", "t{n}", ", ", genericCount))
                .Replace("<T>", FromTemplate("<{0}>", "T{n}", ", ", genericCount))
                .Replace("{T}", FromTemplate("{{{0}}}", "T{n}", ", ", genericCount))
                .Replace("(T value)", FromTemplate("(({0}) value)", "T{n}", ", ", genericCount))
                .Replace("(T t)", FromTemplate("({0})", "T{n} t{n}", ", ", genericCount))
                .Replace("(t)", FromTemplate("({0})", "t{n}", ", ", genericCount))
                .Replace("var t =", FromTemplate("var ({0}) =", "t{n}", ", ", genericCount))
                .Replace(" T ", FromTemplate(" ({0}) ", "T{n}", ", ", genericCount))
                .Replace(" t;", FromTemplate(" ({0});", "t{n}", ", ", genericCount))
                // 生成 [GeneratedCode]。
                .Replace("    public interface ", $"    {Generatedattribute}{NewLine}    public interface ")
                .Replace("    public class ", $"    {Generatedattribute}{NewLine}    public class ")
                .Replace("    public sealed class ", $"    {Generatedattribute}{NewLine}    public sealed class ")
                .AppendLine();
            return GeneratedHeader + content;
        }

        /// <summary>
        /// 使用 <paramref name="seperator"/> 指定的分隔符，将 <paramref name="part"/> 重复 <paramref name="count"/> 次；
        /// 最后，将生成的内容插入到 <paramref name="template"/> 中替换 “{0}” 中，得到最终的字符串。
        /// <para/>
        /// 例如，模板为 “({0})”，部件为 “T{n}”，分隔符为 “, ”，重复次数为 3，则得到 (T1, T2, T3)。
        /// </summary>
        /// <param name="template">模板，任意的字符串，但使用 “{0}” 来指代模板中可以插入的内容。</param>
        /// <param name="part">部件，任意的字符串，但使用 “{n}” 来指代次数 1、2、3。</param>
        /// <param name="seperator">分隔符，任意的字符串，通常使用 “, ”。</param>
        /// <param name="count">重复次数，每重复一次，将替换一次部件中的 “{n}”。</param>
        /// <returns>跟进模板拼接的最终字符串。</returns>
        private static string FromTemplate(string template, string part, string seperator, int count) =>
            string.Format(CultureInfo.InvariantCulture, template,
                string.Join(seperator, Enumerable.Range(1, count)
                    .Select(x => part.Replace("{n}", x.ToString(CultureInfo.InvariantCulture)))));
    }
}
